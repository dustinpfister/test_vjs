<html>
    <head>
        <title>MVP Little City</title>

    </head>
    <body>

        <!-- canvas -->
        <div id="canvas-app"></div>

<script>

//-------- ----------
//  UTILS
//-------- ----------
// UTILS
var utils = {};

//
// MISC
//

// get a value by way of a per value (0-1), and a min and max value
utils.valueByRange = function(per, a, b){
    per = per === undefined ? 0 : per;
    per = per < 0 ? 0 : per;
    per = per > 1 ? 1 : per;
    var nMin, nMax;
    if(typeof a === 'object'){
        nMin = a[0];
        nMax = a[1];
    }else{
        nMin = a === undefined ? 0 : a;
        nMax = b === undefined ? 1 : b;
    }
    var result = nMin + Math.round(per * (nMax - nMin));
    return result;
};

// bounding box
utils.boundingBox = function (x1, y1, w1, h1, x2, y2, w2, h2) {
    return !(
        (y1 + h1 < y2 ||
        y1 > y2 + h2) ||
        x1 + w1 < x2 ||
        x1 > x2 + w2);
};
utils.boundingBox2 = function (x1, y1, w1, h1, x2, y2, w2, h2) {
    return !(
        (y1 + h1 <= y2 ||
        y1 >= y2 + h2) ||
        x1 + w1 <= x2 ||
        x1 >= x2 + w2);
};
// distance
utils.distance = function (x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};

//
// OBJECT
//

// deep clone using JSON
utils.deepCloneJSON = function (obj) {
    try{
       return JSON.parse(JSON.stringify(obj));
    }catch(e){
        return {};
    }
};


//
// DOM
//

// create a canvas element
utils.createCanvas = function (opt) {
    opt = opt || {};
    opt.container = opt.container || document.getElementById('canvas-app') || document.body;
    opt.canvas = document.createElement('canvas');
    opt.ctx = opt.canvas.getContext('2d');
    // assign the 'canvas_example' className
    opt.canvas.className = 'canvas_example';
    // set native width
    opt.canvas.width = opt.width === undefined ? 320 : opt.width;
    opt.canvas.height = opt.height === undefined ? 240 : opt.height;
    // translate by 0.5, 0.5
    opt.ctx.translate(0.5, 0.5);
    // disable default action for onselectstart
    opt.canvas.onselectstart = function () {
        return false;
    }
    // append canvas to container
    opt.container.appendChild(opt.canvas);
    return opt;
};
// get a point relative to a canvas element rather than window
utils.getCanvasRelative = function (e) {
    var canvas = e.target,
    bx = canvas.getBoundingClientRect(),
    pos = {
        x: Math.floor((e.touches ? e.touches[0].clientX : e.clientX) - bx.left),
        y: Math.floor((e.touches ? e.touches[0].clientY : e.clientY) - bx.top),
        bx: bx
    };
    // adjust for native canvas matrix size
    pos.x = Math.floor((pos.x / canvas.scrollWidth) * canvas.width);
    pos.y = Math.floor((pos.y / canvas.scrollHeight) * canvas.height);
    return pos;
};

//-------- ----------
// MAP
//-------- ----------
var mapMod = (function () {
    // PUBLIC API
    var api = {
       ver: 'r3'
    };
    // create Cells helper
    var createCells = function (map) {
        var cells = [];
        var len = map.w * map.h,
        i = 0;
        while (i < len) {
            cells.push({
                i: i,
                x: i % map.w,
                y: Math.floor(i / map.w),
                walkable: true,
                closed: false,
                data: {},
                unit: null // reference to current unit here or null if empty
            });
            i += 1;
        }
        return cells;
    };

// CREATE

    // create a new map object
    api.create = function (opt) {
        opt = opt || {};
        var map = {
            w: opt.w || 9,
            h: opt.h || 7,
            cellSize: opt.cellSize || 32,
            margin: {
                x: opt.marginX == undefined ? 5 : opt.marginX,
                y: opt.marginY == undefined ? 5 : opt.marginY
            },
            cells: []
        };
        map.cells = opt.cells || createCells(map);
        return map;
    };

// GET CELL by...

    // return a cell at the given position, or false for out of bounds values
    api.get = function (map, xi, y) {
        if(arguments.length === 2){
            return map.cells[xi];
        }
        if (xi < 0 || y < 0 || xi >= map.w || y >= map.h) {
            return false;
        }
        return map.cells[y * map.w + xi];
    };
    // get a cell in the current map by way of
    // a canvas relative x and y pixel pos
    api.getCellByPointer = function (map, x, y) {
        var cx = Math.floor((x - map.margin.x) / map.cellSize),
        cy = Math.floor((y - map.margin.y) / map.cellSize);
        return api.get(map, cx, cy)
    };

// Get a collection of cells by...

    api.getCollectionByPos = function(map, sx, sy, w, h){
        var collection = [];
        var i = 0, x, y,
        cell,
        len = w * h;
        while(i < len){
            x = sx + i % w;
            y = sy + Math.floor(i / w);
            cell = api.get(map, x, y);
            if(cell){
                collection.push(cell);
            }
            i += 1;
        }
        return collection;


    };

// for each cell
    api.forEachCell = function(map, func){
        var i = 0, cell,
        len = map.cells.length;
        while(i < len){
            cell = map.cells[i];
            func.call(map, cell, cell.x, cell.y, cell.i, map)
            i += 1;
        }
    };

// PATHS

    // sort a list of open nodes
    var sortOpen = function (opened) {
        return opened.sort(function (nodeA, nodeB) {
            if (nodeA.weight < nodeB.weight) {
                return 1;
            }
            if (nodeA.weight > nodeB.weight) {
                return -1;
            }
            return 0;
        });
    };

    // set weight for a node
    var setWeight = function (endNode, neighbor) {
        return utils.distance(endNode.x, endNode.y, neighbor.x, neighbor.y);
    };

    // build a path based an parent property
    var buildPath = function (node) {
        var path = [];
        while (node.parent) {
            path.push([node.x, node.y]);
            node = node.parent;
        }
        //path.push([node.x, node.y]);
        return path;
    };

    // for Each Neighbor for the given grid, node, and open list
    var forNeighbors = function (grid, node, endNode, opened) {
        //var neighbors = grid.getNeighbors(node);
        var neighbors = mapMod.getNeighbors(grid, node);
        var ni = 0,
        nl = neighbors.length;
        while (ni < nl) {
            var neighbor = neighbors[ni];
            // if the neighbor is closed continue looping
            if (neighbor.closed) {
                ni += 1;
                continue;
            }
            // set weight for the neighbor
            neighbor.weight = setWeight(endNode, neighbor);
            // if the node is not opened
            if (!neighbor.opened) {
                neighbor.parent = node;
                opened.push(neighbor);
                neighbor.opened = true;
            }
            ni += 1;
        }
    };

    api.getPath = function (grid, sx, sy, ex, ey) {
        var grid = utils.deepCloneJSON(grid),
        nodes = api.chunk(grid),
        path = [],
        opened = [],
        node;
        // set startNode and End Node to copy of grid
        var startNode = nodes[sy][sx];
        endNode = nodes[ey][ex];
        // push start Node to open list
        opened.push(startNode);
        startNode.opened = true;
        startNode.weight = 0;
        // start walking
        while (opened.length > 0) {
            // pop out next Node from open list
            node = opened.pop();
            node.closed = true;
            // if the node is the end node
            if (node === endNode) {
                return buildPath(node);
            }
            // loop current neighbors
            forNeighbors(grid, node, endNode, opened);
            // sort the list of nodes be weight value to end node
            sortOpen(opened);
        }
        // return an empty array if we get here (can not get to end node)
        return [];
    };

    // get a chunk form of a grid
    api.chunk = function (grid) {
        var arr = [],
        row,
        i = 0;
        while (i < grid.cells.length) {
            row = grid.cells.slice(i, i + grid.w);
            arr.push(row);
            i += grid.w;
        }
        return arr;
    };

    // return true if the given x and y position is in bounds
    api.isInBounds = function (grid, x, y) {
        return (x >= 0 && x < grid.w) && (y >= 0 && y < grid.h);
    };

    // is the given cell location walkable?
    api.isWalkable = function (grid, x, y) {
        if (api.isInBounds(grid, x, y)) {
            return api.get(grid, x, y).walkable; //grid.nodes[y][x].walkable;
        }
        return false;
    };

    // get the four Neighbors of a node
    api.getNeighbors = function (grid, node, dirCount) {
        var x = node.x,
        y = node.y,
        neighbors = [];
        dirCount = dirCount === undefined ? 4 : dirCount;
        // for dircount 4 or 8
        if(dirCount === 4 || dirCount === 8){
            if (api.isWalkable(grid, x, y - 1)) {
                neighbors.push(mapMod.get(grid, x, y - 1));
            }
            if (api.isWalkable(grid, x, y + 1)) {
                neighbors.push(mapMod.get(grid, x, y + 1));
            }
            if (api.isWalkable(grid, x - 1, y)) {
                neighbors.push(mapMod.get(grid, x - 1, y));
            }
            if (api.isWalkable(grid, x + 1, y)) {
                neighbors.push(mapMod.get(grid, x + 1, y));
            }
        }
        // for dirCount 8 only
/*
        if(dirCount || 8){
            if (api.isWalkable(grid, x - 1, y - 1)) {
                neighbors.push(mapMod.get(grid, x - 1, y - 1));
            }
            if (api.isWalkable(grid, x + 1, y + 1)) {
                neighbors.push(mapMod.get(grid, x + 1, y + 1));
            }
            if (api.isWalkable(grid, x - 1, y + 1)) {
                neighbors.push(mapMod.get(grid, x - 1, y + 1));
            }
            if (api.isWalkable(grid, x + 1, y - 1)) {
                neighbors.push(mapMod.get(grid, x + 1, y - 1));
            }
        }
*/
        return neighbors;
    };

    // return the public API
    return api;
}
    ());

//-------- ----------
// SM
//-------- ----------
var smMod = (function(){

    var STATES = {

    };

    var api = {};

    api.setState = function(sm, stateKey){
        sm.currentState = stateKey;
        sm.stateObj = sm.states[sm.currentState];
    };

    api.create = function(opt){
        opt = opt || {};
        // canvas
        var canvasObj = utils.createCanvas({
            container : document.getElementById('canvas-app'),
            width: 640,
            height: 480
        });
        // state machine object
        var sm = {
            verSM: 'r0',
            ver: opt.ver || '',
            ctx: canvasObj.ctx,
            canvas: canvasObj.canvas,
            fps: 20,
            lt: new Date(),
            game: {},
            states: STATES,
            currentState: opt.currentState || STATES[0].stateKey,
            stateObj: {}
        };

        // just a click event as of r0 of this
        sm.canvas.addEventListener('click', function(e){
            var pos = utils.getCanvasRelative(e);
            sm.stateObj.events.click(e, pos, sm);
        });

        api.setState(sm, sm.currentState);
        return sm;
    };

    api.load = function(stateObj){
        stateObj.data = stateObj.data || {};
        STATES[stateObj.stateKey] = stateObj;
    };

    api.startLoop = function(sm){
        // main app loop
        var loop = function(){
            var now = new Date(),
            secs = (now - sm.lt) / 1000;
            requestAnimationFrame(loop);
            if(secs > 1 / sm.fps){
                sm.stateObj.update(sm, secs);
                sm.stateObj.draw(sm, sm.ctx, sm.canvas);
                sm.lt = now;
            }
        };
        loop();
    };

    // create simple menus
    api.gridMenu = {};

    api.gridMenu.create = function(opt){
        opt = opt || {};
        var menu = Object.assign({}, {
            x: 32,
            y: 32,
            w: 4,
            h: 4,
            currentIndex: 0,
            cellSize: 32,
            buttons: []
        }, opt);
        return menu;
    };

    api.gridMenu.click = function(menu, pos){
        var w = menu.cellSize * menu.w,
        h = menu.cellSize * menu.h; // * menu.buttons.length / menu.w;


        if(utils.boundingBox2( menu.x, menu.y, w, h, pos.x, pos.y, 1, 1 )){
            var x = Math.floor((pos.x - menu.x) / menu.cellSize);
            var y = Math.floor((pos.y - menu.y) / menu.cellSize);
            var i = y * menu.w + x;
            var button = menu.buttons[i];
            if(button){
                menu.currentIndex = i;
                return button;
            }
        }
        return false;
    }

    return api;

}());

//-------- ----------
// GAME
//-------- ----------
var gameMod = (function(){

    // public api
    var api = {};

    var hardSet = {
        MAX_CELL_POPULATION : 100,
        MAX_CELL_LAND_VALUE : 500,   // 500 point scale for land value as of r2
        MAX_AVG_DIST: 10,            // used in getPathsToZoneValue helper for figuring land value
        MAX_IMMIGR: 15,              // max immigration per update used in getPopDeltaObj helper
        MAX_EXODUS: 15,              // max exodus per update used in getPopDeltaObj helper
        LVPER_ROADCT: 0.10, 
        LVPER_COMCT: 0.10,
        LVPER_COMDIST: 0.80
    };

    var UNIT_TYPES = {};

    UNIT_TYPES.res = {
        cost: 100,
        fillStyle : '#880000'
    };

    UNIT_TYPES.com = {
        cost: 150,
        fillStyle : '#000088'
    };

    UNIT_TYPES.road = {
        cost: 10,
        fillStyle : '#888888'
    };

    // ////////// //////////
    // CREATE A NEW CITY
    // ////////// //////////

    // create a unit for the given cell that is of the given unitKey
    var createUnit = function(cell, unitKey){
        var unitType = UNIT_TYPES[unitKey];
        cell.data.unit = {
            unitKey: unitKey,
            fillStyle: unitType.fillStyle
        };
        // by default walkable bool for a cell should be false
        // and should be set to true just for roads
        cell.walkable = false;
        if(unitKey === 'road'){
            cell.walkable = true;
        }
    };

    api.create = function(opt){
        opt = opt || {};
        // if loading a city, cellData will be needed
        opt.cellData = opt.cellData || [];
        var game = {
            hardSet: hardSet,
            money: 1000, //100,
            population: 0,
            year: 1900,
            secsPerYear: 10,
            secs: 0,
            totals: { com:0, res: 0, road:0 },
            problems: { },
            taxRate: {
                propertyTax: 0.07
            },
            map: mapMod.create({
                w: 10,
                h: 8,
                marginX: 128,
                marginY: 96,
                cellSize: 40
            })
        };
        game.map.cells.forEach(function(cell, i){
            var cDat = cell.data;
            cDat.fillStyle = 'white';
            cDat.landValue = 0;
            cDat.population = 0;
            cDat.popDelta = getPopDeltaObj(game, cell);
            // walkable defaults to false;
            cell.walkable = false;
        });
        // set up cells for any given cellData array
        opt.cellData.forEach(function(cellData){
            var cell = mapMod.get(game.map, cellData.x, cellData.y),
            unitKey = cellData.unitKey;
            createUnit(cell, unitKey);
        });
        return game;
    };

    // ////////// //////////
    // MISC HELPERS AND METHODS
    // ////////// //////////

    // build a unit an the given cell, or cell location
    // gameMod.buildAt(game, 'res', cell)
    // gameMod.buildAt(game, 'res', x, y)
    api.buildAt = function(game, unitKey, a, b){
        var cell = null;
        var unitType = UNIT_TYPES[unitKey];
        if(typeof a === 'object'){
           cell = a;
        }
        if(typeof a === 'number'){
           cell = mapMod.get(game.map, a, b)
        }
        if(game.money >= unitType.cost && cell){
            game.money -= unitType.cost;
            createUnit(cell, unitKey);
        }
    };

    // figure out what the current deltaMoney amount is for a year
    var getDeltaMoney = api.getDeltaMoney = function(game){
        // !!! Property tax ( https://en.wikipedia.org/wiki/Property_tax )
        // !!! as of r0 I just worked out a system system for 'property tax' that will 
        // need to be improved at a latter point as the expression at that point
        // is just Math.floor(game.population * game.raxRate.propertyTax)
        var propertyTax = Math.floor(game.population * game.taxRate.propertyTax);
        // !!! property tax is all that makes money
        var deltaMoney = propertyTax;
        return deltaMoney;
    };

    // GET AN AREA IN THE MAP
    var getArea = api.getArea = function(game, x, y, w, h){
        return game.map.cells.filter(function(cell){
            return utils.boundingBox2(x, y, w, h, cell.x, cell.y, 1, 1);
        });
    };

    // GET A UNIT TYPE IN AN AREA OF THE MAP
    var getTypeInArea = api.getTypeInArea = function(game, unitKey, x, y, w, h){
        x = x === undefined ? 0 : x;
        y = y === undefined ? 0 : y;
        w = w === undefined ? game.map.w : w;
        h = h === undefined ? game.map.h : h;
        return getArea(game, x, y, w, h).filter(function(cell){
            if(cell.data.unit){
                return cell.data.unit.unitKey === unitKey;
            }
            return false;
        });
    };

    var getTypeFromCellDist = api.getTypeFromCellDist = function(game, cell, unitKey, dist){
        dist = dist === undefined ? 3: dist;
        var s = dist * 2 + 1;
        return api.getTypeInArea(game, 'road', cell.x - dist, cell.y - dist, s, s);
    };

    // with the given collection return the cell in the colletion that is near the given cell
    // might return null of no cell is near at all in the collection
    var getNear = function(cellCollection, cell){
        var dist = Infinity,
        nearCell = null;
        cellCollection.forEach(function(target){
            var d = utils.distance(cell.x, cell.y, target.x, target.y);
            if(d < dist){
                dist = d;
                nearCell = target;
            }
        });
        return nearCell;
    };

    var getZonePaths = function(game, zoneUnitKey, a, b){
        var homeCell;
        if(typeof a === 'object'){
            homeCell = a;
        }else{        
            homeCell = mapMod.get(game.map, a, b);
        }
        var pathsObj = {
            homeCell: homeCell,
            sCell: null,
            zones: []
        };
        var roads = getTypeFromCellDist(game, homeCell, 'road', 3);
        if(roads.length >= 1){
            var zones = getTypeInArea(game, zoneUnitKey);
            var sCell = pathsObj.sCell = getNear(roads, homeCell);
            var roads = getTypeInArea(game, 'road');
            zones.forEach(function(zoneCell){
                var eCell = getNear(roads, zoneCell),
                path = mapMod.getPath(game.map, sCell.x, sCell.y, eCell.x, eCell.y);
                path.push([sCell.x, sCell.y]);
                // distance from end of path to zoneCell
                var d = utils.distance(zoneCell.x, zoneCell.y, path[0][0], path[0][1] );
                if(d <= 3){
                    pathsObj.zones.push({
                        zoneCell: zoneCell,
                        eCell: eCell,
                        path: path
                    });
                }
            });
        }
        return pathsObj;
    };

    // ////////// //////////
    // PROBLEMS
    // ////////// //////////

    // COLLECTION OF PROBELMS THAT INPACT THE HEALTH OF THE CITY
    var PROBLEMS = {};

    // problems that impact popDelta
    PROBLEMS.popDelta = {};

    // if taxes are two high that can being down immgr, and increase exodus
    // however lower taxes can increase immgr and reduce exodus
    PROBLEMS.popDelta.highTaxes = function(game, cell){
        var deltas = {
            index: 0,
            immigr: 0,
            exodus: 0
        };
        // tax rate and tax per
        var tr = game.taxRate.propertyTax,
        taxPer = tr / 0.20;
        // index value for the high tax problem
        deltas.index = taxPer;
        //immigrRate best: [5, 15], worst: [4, 13]
        //exodusRate best = [0, 10], worst: [5, 15]
        var immigrRate = [1, 5];
        var exodusRate = [0, 0];
        immigrRate[0] = utils.valueByRange(  1 - taxPer, [ 4, 5 ] ); 
        immigrRate[1] = utils.valueByRange(  1 - taxPer, [ 13, 15 ] );
        exodusRate[0] = utils.valueByRange(  taxPer, [ 0, 5 ] ); 
        exodusRate[1] = utils.valueByRange(  taxPer, [ 10, 15 ] );
        deltas.immigr = utils.valueByRange( Math.random(), immigrRate);
        deltas.exodus = utils.valueByRange( Math.random(), exodusRate );
        // return the deltas that are the result of this problem for this cell
        return deltas;
    };

    // people will move out if the comm to res ratio is to low
    PROBLEMS.popDelta.unemployment = function(game, cell){
        var deltas = {
            index: 0,
            immigr: 0,
            exodus: 0
        };
        var t = game.totals;
        var comRatio = t.com / t.res;
        if(String(comRatio) === 'NaN' || comRatio === Infinity){
            comRatio = 1;
        }
        if(comRatio < 0.25){
            deltas.index = ( 0.25 - comRatio ) / 0.25;
            deltas.exodus = Math.round( 1 + 2 * deltas.index );
        }
        return deltas;
    };

    // ////////// //////////
    // POPULATION
    // ////////// //////////

    // get a pop delta object for the given cell
    var getPopDeltaObj = function(game, cell){
        // starting pop delta
        var popDelta = {
            immigr: 0, 
            exodus: 0,
            valueOf : function(){
                return this.immigr - this.exodus;
            }
        };

        Object.keys(PROBLEMS.popDelta).forEach(function(problemKey){
            var problemFunc = PROBLEMS.popDelta[problemKey];
            var delta = problemFunc(game, cell);
            popDelta.immigr += delta.immigr;
            popDelta.exodus += delta.exodus;
            // !!! Tabulating problem index totals here
            var p = game.problems[problemKey];
            if(p){
                p.count += delta.index > 0 ? 1 : 0;
                p.index += delta.index;
            }
        });

        // apply caps for immigr and exodus 
        popDelta.immigr = popDelta.immigr > hardSet.MAX_IMMIGR ? hardSet.MAX_IMMIGR : popDelta.immigr;
        popDelta.exodus = popDelta.exodus > hardSet.MAX_EXODUS ? hardSet.MAX_EXODUS : popDelta.exodus;
        popDelta.immigr = popDelta.immigr < 0 ? 0 : popDelta.immigr;
        popDelta.exodus = popDelta.exodus < 0 ? 0 : popDelta.exodus;

        return popDelta;
    };

    // update pop value for a single cell to be used in main update loop ( see api.update )
    var updatePopForCell = function(game, cell){
        // for each cell...
            var cDat = cell.data;
            if(cDat.unit){
                if(cDat.unit.unitKey === 'res'){
                    cDat.population += cDat.popDelta.valueOf();
                    var per = cDat.landValue / hardSet.MAX_CELL_LAND_VALUE;
                    var currentCellPopCap = Math.round( per * hardSet.MAX_CELL_POPULATION );
                    if(cDat.population > currentCellPopCap){
                        cDat.population = currentCellPopCap;
                    }
                    if(cDat.population < 0){
                        cDat.population = 0;
                    }
                }else{
                    // any unit other then res will not have any population or popDelta
                    cDat.population = 0;
                }
            }else{
                // any blank cell that does not have a unit, will not have any population or popDelta
                cDat.population = 0;
            }
    };

    // ////////// //////////
    // LAND VALUE
    // ////////// //////////

    // main update method as well as all relevant helper methods for figuring land value for each cell

    // just get a land value delta based just on the count of roads around a cell
    var getRoadCountValue = function(cell, roads){
        var per = roads.length / 10;
        per = per > 1 ? 1 : per;
        // 25% based on road count (r2)
        return hardSet.MAX_CELL_LAND_VALUE * hardSet.LVPER_ROADCT * per;
    };

    // get a value based on count of zones and avg path length to zones
    var getPathsToZoneValue = function(game, cell, unitKey){
        // get raw paths obj
        var pathsObj = getZonePaths(game, unitKey, cell);
        // on zones? return 0
        if(pathsObj.zones.length === 0){
            return 0;
        }
        // figure avg dist
        var avgDist = pathsObj.zones.reduce(function(acc, zoneObj){
            return acc + zoneObj.path.length;
        }, 0) / pathsObj.zones.length;
        // avgDist should never be lower then 1, and if over 10
        // then that is all ready the worst
        var maxAvgDist = hardSet.MAX_AVG_DIST;
        avgDist = avgDist < 1 ? 1 : avgDist;
        avgDist = avgDist > maxAvgDist ? maxAvgDist : avgDist;
        var dPer = 1 - (avgDist - 1) / ( maxAvgDist - 1);
        // 50% based on distance (r2)
        var val = hardSet.MAX_CELL_LAND_VALUE * hardSet.LVPER_COMDIST * dPer;
        // 25% based on count (r2)
        var count = pathsObj.zones.length;
        var cPer = count / 5;
        cPer = cPer > 1 ? 1 : cPer;
        val += hardSet.MAX_CELL_LAND_VALUE * hardSet.LVPER_COMCT * cPer;
        // return val
        return val;
    };

    // update land value for a single cell to be used in main update loop ( see api.update )
    var updateLandValueForCell = function(game, cell){
        var cDat = cell.data;
        // land value should default to 0
        cDat.landValue = 0;
        if(cDat.unit){
            if(cDat.unit.unitKey === 'res'){
                // a res zone must have at least one or more roads within 3 cells
                // or else it will not develop at all
                var roads = getTypeFromCellDist(game, cell, 'road', 3);
                if(roads.length >= 1){
                    // simple road count value for res, and also paths to 'com' cells
                    cDat.landValue += getRoadCountValue(cell, roads);
                    cDat.landValue += getPathsToZoneValue(game, cell, 'com')
                }
            }
        }
        cDat.landValue = Math.round(cDat.landValue);
        // apply max land value limit
        cDat.landValue = cDat.landValue > hardSet.MAX_CELL_LAND_VALUE ? hardSet.MAX_CELL_LAND_VALUE : cDat.landValue; 
    };

    // ////////// //////////
    // TOTALS
    // ////////// //////////

    // reset totals
    var resetTotals = function(game){
        var t = game.totals;
        t.com = 0;
        t.res = 0;
        t.road = 0;
        t.land = 0;
        
        // index values for each problem
        Object.keys(PROBLEMS.popDelta).forEach(function(problemKey){
            game.problems[problemKey] = {
                count: 0,
                index: 0,
                key: problemKey
            }
        });

    };
    // step totals, to be called in main cell update loop ( see api.update )
    var stepTotalsForCell = function(game, cell){
        var t = game.totals;
        var unit = cell.data.unit; 
        if(unit){
            t[unit.unitKey] += 1;
        }else{
           t.land += 1;
        }
    };

    // The Main gameMod.update method
    api.update = function(game, secs){

        // reset, and re tabulate totals
        resetTotals(game);
        var i = 0, len = game.map.cells.length, cell;
        while(i < len){
            cell = game.map.cells[i];
            stepTotalsForCell(game, cell);
            i += 1;
        }

        // global population defaulting to zero
        game.population = 0;
        // single loop of cells here in the main app loop
        var i = 0, len = game.map.cells.length, cell;
        while(i < len){
            cell = game.map.cells[i];
            updateLandValueForCell(game, cell);
            cell.data.popDelta = getPopDeltaObj(game, cell);
            updatePopForCell(game, cell); 
            // tabulate for total pop
            game.population += cell.data.population;
            i += 1;
        };

        // create index values for game.problems
        Object.keys(PROBLEMS.popDelta).forEach(function(problemKey){
             var p = game.problems[problemKey];
             p.index = p.index / p.count;
             p.index = String(p.index) === 'NaN' ? 0 : p.index;
        });

        // new year?
        game.secs += secs;
        var spy = game.secsPerYear;
        game.secs = game.secs > spy ? spy : game.secs;
        if(game.secs === spy){
            game.year += 1;
            game.secs = 0;
            game.money += getDeltaMoney(game);
        }
    };

    return api;


}())
//-------- ----------
// DRAW
//-------- ----------
var draw = (function () {

    var LAND_COLORS = ['green', 'lime', 'yellow', 'orange', 'red'],
    POP_COLORS = ['#220022', '#550055', '#880088', '#ff00ff']

    // public api
    var api = {};


/********** **********
     HELPERS
*********** *********/

var drawCellText = function(ctx, map, cell, text){
    var cs = map.cellSize;
    var x = map.margin.x + cell.x * cs + cs / 2;
    var y = map.margin.y + cell.y * cs + cs / 2;
    ctx.fillStyle = '#8f8f8f';
    ctx.textAlign = 'center';
    ctx.font = '12px courier';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y)
};

var rect = function(ctx, x, y, w, h){
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.fill();
    ctx.stroke();
};

// draw a cell helper
var drawCell = function(sm, map, cell, layer){
    layer = layer || 'normal';
    var ctx = sm.ctx;
    var cs = map.cellSize;
    var x = map.margin.x + cell.x * cs;
    var y = map.margin.y + cell.y * cs;
    drawCell[layer](sm, ctx, cell, x, y, cs);
};

drawCell.normal = function(sm, ctx, cell, x, y, cs){
    ctx.fillStyle = cell.data.fillStyle || 'white';
    ctx.strokeStyle = 'black';
    if(cell.data.unit){
        ctx.fillStyle = cell.data.unit.fillStyle;
    }
    rect(ctx, x, y, cs, cs);
};

drawCell.value = function(sm, ctx, cell, x, y, cs){
    var per = cell.data.landValue / sm.game.hardSet.MAX_CELL_LAND_VALUE;
    ctx.fillStyle = 'black';
    if(per != 0){
        ctx.fillStyle = LAND_COLORS[Math.round((LAND_COLORS.length - 1) * per)];
    }
    ctx.strokeStyle = 'white';
    rect(ctx, x, y, cs, cs);
    drawCellText(ctx, sm.game.map, cell, cell.data.landValue);
};

drawCell.population = function(sm, ctx, cell, x, y, cs){
    var per = cell.data.population / sm.game.hardSet.MAX_CELL_POPULATION;
    ctx.fillStyle = 'black';
    if(per != 0){
        ctx.fillStyle = POP_COLORS[Math.round((POP_COLORS.length - 1) * per)];
    }
    ctx.strokeStyle = 'white';
    rect(ctx, x, y, cs, cs);
    drawCellText(ctx, sm.game.map, cell, cell.data.population);
};

drawCell.roads = function(sm, ctx, cell, x, y, cs){
    ctx.fillStyle = 'black';
    if(cell.walkable){
        ctx.fillStyle = 'orange';
    }
    rect(ctx, x, y, cs, cs);
};

/********** **********
     PUBLIC API
*********** *********/

    // draw background
    api.back = function (sm, style) {
        var canvas = sm.canvas,
        ctx = sm.ctx;
        ctx.fillStyle = style || 'black';
        ctx.fillRect(-1, -1, canvas.width + 2, canvas.height + 2);
    };
    // draw the map
    api.map = function (sm, map, layer) {
        var i = 0,
        len = map.cells.length;
        while (i < len) {
            drawCell(sm, map, map.cells[i], layer);
            i += 1;
        }
    };
    // draw the build menu
    api.menu = function(sm, menu){
        var canvas = sm.canvas,
        ctx = sm.ctx,
        bm = menu || sm.buildMenu,
        cs = bm.cellSize;
        ctx.save();
        ctx.translate(bm.x, bm.y);
        bm.buttons.forEach(function(button, i){
            var x = i % bm.w,
            y = Math.floor(i / bm.w);
            ctx.fillStyle = i === bm.currentIndex ? 'yellow' : 'white';
            ctx.fillRect(x * cs, y * cs, cs, cs);
            // text
            ctx.font = '10px courier';
            ctx.textBaseline = 'top';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'black';
            ctx.fillText(button.desc, x * cs + 4, y * cs + 12);
        });
        ctx.restore();
    };

    var standardText = function(ctx){
        ctx.fillStyle = 'white';
        ctx.font = '10px courier';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
    };

    // draw standard display
    api.disp = function(sm){
        var ctx = sm.ctx,
        canvas = sm.canvas;
        // text style
        standardText(ctx);
        // version number
        ctx.fillText('money: ' + sm.game.money + ', pop: ' + sm.game.population + ', year: ' + sm.game.year, 5, 5);
    };

    api.dispBudget = function(sm){
        var ctx = sm.ctx, canvas = sm.canvas,
        tr = sm.game.taxRate.propertyTax;
        // text style
        standardText(ctx);
        ctx.font = '15px courier';
        var y = 128 + 7, x = 200,
        dy = 15,
        sDat = sm.stateObj;
        ctx.fillText('property tax rate: ' + Math.round(tr * 100) + '%', x, y);
        ctx.fillText('income: ' + sDat.income, x, y + dy * 14);
        ctx.fillText('Money Next Year: ' + sDat.moneyNextYear, x, y + dy * 15);
    };

    // draw version number
    api.ver = function(sm){
        var ctx = sm.ctx,
        canvas = sm.canvas;
        // text style
        standardText(ctx);
        // version number
        ctx.fillText('version: ' + sm.ver, 5, canvas.height - 15);
    };
    // return the public api to draw variable
    return api;
}
    ());

//-------- ----------
// STATE - INIT
//-------- ----------
smMod.load({
    stateKey: 'init',
    update: function(sm, secs){

        // set up the build menu
        sm.buildMenu = smMod.gridMenu.create({
            x: 16,
            y: 96,
            w: 2, h: 3,
            currentIndex: 0,
            cellSize: 45,
            buttons: [
                { desc: 'sel', unitKey: 'sell', action: 'sell'},
                { desc: 'inf', unitKey: 'info', action: 'info'},
                { desc: 'res', unitKey: 'res', action: 'build' },
                { desc: 'com', unitKey: 'com', action: 'build' },
                { desc: 'rod', unitKey: 'road', action: 'build' }
            ]
        });

        // set up game state menu
        sm.gameStateMenu = smMod.gridMenu.create({
            x: 16,
            y: 25,
            w: 5,
            currentIndex: 0,
            cellSize: 50,
            buttons: [
                { desc: 'build',  action: 'gameBuild'},
                { desc: 'map',  action: 'gameMap'},
                { desc: 'budget',  action: 'gameBudget'},
                { desc: 'totals', action: 'gameTotals'},
                { desc: 'voice', action: 'gameVoice'}
            ]
        });

        // set up the map menu
        sm.mapMenu = smMod.gridMenu.create({
            x: 16,
            y: 96,
            w: 2,
            currentIndex: 0,
            cellSize: 45,
            buttons: [
                { desc: 'val', unitKey: 'val', action: 'value'},
                { desc: 'pop', unitKey: 'pop', action: 'population'},
                { desc: 'road', unitKey: 'road', action: 'roads'}
            ]
        });

        sm.budgetMenu = smMod.gridMenu.create({
            x: 420,
            y: 128,
            w: 2,
            currentIndex: 0,
            cellSize: 32,
            buttons: [
               {desc: 'pt+', action: 'prop_pos'},
               {desc: 'pt-', action: 'prop_neg'}
            ]
        });

        // create game object
        sm.game = gameMod.create({
            cellData: [
                { x: 0, y: 1, unitKey: 'road'},
                { x: 1, y: 1, unitKey: 'road'},
                { x: 2, y: 1, unitKey: 'road'},
                { x: 3, y: 1, unitKey: 'road'},
                { x: 3, y: 2, unitKey: 'road'},
                { x: 3, y: 3, unitKey: 'road'},
                { x: 3, y: 4, unitKey: 'road'},
                { x: 4, y: 4, unitKey: 'road'},
                { x: 5, y: 4, unitKey: 'road'},
                { x: 6, y: 4, unitKey: 'road'},
                { x: 7, y: 4, unitKey: 'road'},
                { x: 7, y: 3, unitKey: 'road'},
                { x: 7, y: 2, unitKey: 'road'},
                { x: 7, y: 1, unitKey: 'road'},
                { x: 7, y: 0, unitKey: 'road'},

                { x: 2, y: 2, unitKey: 'com'},
                { x: 2, y: 3, unitKey: 'com'},
                { x: 2, y: 4, unitKey: 'com'},
                { x: 2, y: 5, unitKey: 'com'},
                { x: 2, y: 6, unitKey: 'com'},

                { x: 4, y: 3, unitKey: 'res'},
                { x: 5, y: 3, unitKey: 'res'},
                { x: 6, y: 3, unitKey: 'res'},
                { x: 6, y: 2, unitKey: 'res'},

                { x: 8, y: 0, unitKey: 'res'},
                { x: 9, y: 0, unitKey: 'res'},
                { x: 8, y: 1, unitKey: 'res'},
                { x: 9, y: 1, unitKey: 'res'}

            ]

        });

        // switch to gameBuild state
        smMod.setState(sm, 'gameBuild');
    },
    draw: function(sm, ctx, canvas){},
    events: { click: function(e, pos, sm){}}
});

//-------- ----------
// STATE - GAME BUILD
//-------- ----------
smMod.load({
    stateKey: 'gameBuild',
    data: {
        cellWindowActive: false, // if true the cell window is active
        selectedCell: null,
        cellInfo: {}
    },
    update: function(sm, secs){
        var sDat = sm.stateObj.data;
        gameMod.update(sm.game, secs);
        if(sDat.selectedCell){
            var cell = sDat.selectedCell;
            var cInfo = sDat.cellInfo = {
                x: cell.x, y: cell.y
            };
            var unit = cell.data.unit;
            if(unit){
                var unitKey = cInfo.unitKey = unit.unitKey;
                if(unitKey === 'res'){
                    cInfo.population = cell.data.population;
                    //cInfo.immigrRate = cell.data.immigrRate;
                    cInfo.immigr = cell.data.popDelta.immigr;
                    cInfo.exodus = cell.data.popDelta.exodus;
                    cInfo.landValue = cell.data.landValue;
                }
            }
        }
    },
    draw: function(sm, ctx, canvas){
        var sDat = sm.stateObj.data;
        draw.back(sm);
        draw.map(sm, sm.game.map, 'normal');
        if(sDat.cellWindowActive){
            draw.back(sm, 'rgba(0,0,0,0.8)');
            ctx.fillStyle = 'yellow';
            ctx.font = '15px arial';
            var x = 64,
            y = 64;
            Object.keys(sDat.cellInfo).forEach(function(key, i){
                ctx.fillText(key + ': ' + sDat.cellInfo[key], x, y + 16 * i);
            });
        }else{
            draw.menu(sm, sm.buildMenu);
            draw.menu(sm, sm.gameStateMenu);
        }
        draw.disp(sm);
        draw.ver(sm);
    },
    events: {
        click: function(e, pos, sm){
            var sDat = sm.stateObj.data;
            var cell = mapMod.getCellByPointer(sm.game.map, pos.x, pos.y);

            if(sDat.cellWindowActive){
                sDat.cellWindowActive = false;
                sDat.selectedCell = null;
            }else{
                // if map cell clicked
                if(cell){
                    var button = sm.buildMenu.buttons[sm.buildMenu.currentIndex];
                    var unitKey = button.unitKey;
                    if(button.action === 'sell'){
                        if(cell.data.unit){
                            cell.data.unit = null;
                            cell.walkable = false;
                            sm.game.money += 50;
                        }else{
                            console.log('no unit to sell');
                        }
                    }
                    if(button.action === 'info'){
                        sDat.cellWindowActive = true;
                        sDat.selectedCell = cell;
                        //sDat.cellInfo = Object.assign({}, cell.data, {x: cell.x, y: cell.y, walkable: cell.walkable});
                        //console.log( Object.assign({}, cell.data, {x: cell.x, y: cell.y, walkable: cell.walkable}) );
	                //console.log( mapMod.getPath(sm.game.map, 3, 5, 3, 3) );		
                    }
                    if(button.action === 'build'){
                        gameMod.buildAt(sm.game, unitKey, cell);
                    }
                }
                // if build menu clicked
                smMod.gridMenu.click(sm.buildMenu, pos);
                var button = smMod.gridMenu.click(sm.gameStateMenu, pos);
                if(button){
                    smMod.setState(sm, button.action)
                }
            }
        }
    }
});

//-------- ----------
// STATE - GAME MAP
//-------- ----------
smMod.load({
    stateKey: 'gameMap',
    update: function(sm, secs){
        gameMod.update(sm.game, secs)
    },
    draw: function(sm, ctx, canvas){
        draw.back(sm);
        var mapButton = sm.mapMenu.buttons[sm.mapMenu.currentIndex];
        draw.map(sm, sm.game.map, mapButton.action);
        draw.menu(sm, sm.gameStateMenu);
        draw.menu(sm, sm.mapMenu);
        draw.disp(sm);
        draw.ver(sm);
    },
    events: {
        click: function(e, pos, sm){
            // if map menu clicked
            smMod.gridMenu.click(sm.mapMenu, pos);
            // game state change?
            var button = smMod.gridMenu.click(sm.gameStateMenu, pos);
            if(button){
                smMod.setState(sm, button.action)
            }
        }
    }
});

//-------- ----------
// STATE - GAME BUDGET
//-------- ----------
smMod.load({
    stateKey: 'gameBudget',
    data: {
       income: 0,
       moneyNextYear: 0
    },
    update: function(sm, secs){
        var sDat = sm.stateObj;
        gameMod.update(sm.game, secs);
        sDat.income = gameMod.getDeltaMoney(sm.game);
        sDat.moneyNextYear = sm.game.money + sDat.income;
    },
    draw: function(sm, ctx, canvas){
        draw.back(sm);
        draw.menu(sm, sm.gameStateMenu);
        draw.menu(sm, sm.budgetMenu);
        draw.disp(sm);
        draw.dispBudget(sm); // show budget display text
        draw.ver(sm);
    },
    events: {
        click: function(e, pos, sm){
            var game = sm.game;
            // was the budget menu clicked?
            var button = smMod.gridMenu.click(sm.budgetMenu, pos);
            if(button){
                var parts = button.action.split('_')
                // if a property tax button
                if(parts[0] === 'prop'){
                    var tr = game.taxRate.propertyTax; 
                    if(parts[1] === 'pos'){
                        tr += 0.01;
                    }else{
                        tr -= 0.01;
                    }
                    tr = parseFloat( tr.toFixed(2) );
                    tr = tr < 0 ? 0 : tr;
                    tr = tr > 0.20 ? 0.20 : tr;
                    game.taxRate.propertyTax = tr;
                }
            }
            // was the game state menu is clicked?
            var button = smMod.gridMenu.click(sm.gameStateMenu, pos);
            if(button){
                smMod.setState(sm, button.action)
            }
        }
    }
});

//-------- ----------
// STATE - GAME TOTALS
//-------- ----------
smMod.load({
    stateKey: 'gameTotals',
    update: function(sm, secs){
        gameMod.update(sm.game, secs)
    },
    draw: function(sm, ctx, canvas){
        draw.back(sm);
        draw.menu(sm, sm.gameStateMenu);
        ctx.fillStyle = 'yellow';
        ctx.font = '15px arial';
        var x = 28, y = 128;
        Object.keys(sm.game.totals).forEach(function(key, i){
            ctx.fillText(key + ': ' + sm.game.totals[key] , x, y + 17 * i);
        });
        draw.disp(sm);
        draw.ver(sm);
    },
    events: {
        click: function(e, pos, sm){
            // game state change?
            var button = smMod.gridMenu.click(sm.gameStateMenu, pos);
            if(button){
                smMod.setState(sm, button.action)
            }
        }
    }
});

//-------- ----------
// STATE - GAME VOICE
//-------- ----------
smMod.load({
    stateKey: 'gameVoice',
    update: function(sm, secs){
        gameMod.update(sm.game, secs)
    },
    draw: function(sm, ctx, canvas){
        draw.back(sm);
        draw.menu(sm, sm.gameStateMenu);
        ctx.fillStyle = 'yellow';
        ctx.font = '15px arial';
        ctx.fillText('City Problems: ' , 28, 180);
        var x = 28, y = 200;
        Object.keys(sm.game.problems).forEach(function(key, i){
            var p = sm.game.problems[key];
            var percentStr = Math.round(p.index * 100) + '%';
            ctx.fillText(key + ': ' + percentStr , x, y + 17 * i);
        });
        draw.disp(sm);
        draw.ver(sm);
    },
    events: {
        click: function(e, pos, sm){
            // game state change?
            var button = smMod.gridMenu.click(sm.gameStateMenu, pos);
            if(button){
                smMod.setState(sm, button.action)
            }
        }
    }
});

//-------- ----------
// MAIN
//-------- ----------
var sm = smMod.create({
    ver: 'r4',
    currentState: 'init'
});

smMod.startLoop(sm);


</script>

 

    </body>
</html>